fn vecrev
  0
  1 nbrot
fn vecrev_start
  1 pushnth 1 pushnth < ! vecrev_end :if
  1 nbrot
    1 +
  1 nbrot
  0 pushnth 1 + pushnth
  2 pushnth 1 + nbrot
  0 pushnth 2 + dropnth
  vecrev_start :
fn vecrev_end
  1 + pushnth 1 pushnth 2 + dropnth :

fn max2 /* 34 35 * */
  2 pushnth 2 pushnth < max2_else :if
  1 dropnth :
fn max2_else
  2 dropnth :

fn veccpy 1 pushnth 1 + nbrot
  0
  1 nbrot
fn veccpy_loop
  1 nbrot
    1 +
  1 nbrot
  0 pushnth 1 + pushnth
  2 nbrot
  1 pushnth 1 pushnth < ! veccpy_end :if
  veccpy_loop :
fn veccpy_end
  0 pushnth 1 + nbrot
  0 pushnth 1 + 2 * pushnth
  1 pushnth 1 + 2 * 1 + dropnth
  :

fn vecrem 1 pushnth 1 + nbrot
  0 1 nbrot
fn vecrem_loop
  1 nbrot
    1 +
  1 nbrot
  2 dropnth
  1 pushnth 1 pushnth < ! vecrem_end :if
  vecrem_loop :
fn vecrem_end
  0 dropnth 0 dropnth :

fn veceq
  1 pushnth 1 + 0 pushnth 2 + pushnth + 1 + nbrot
  0 pushnth 1 + pushnth 1 pushnth = ! veceq_len_false :if
  0 pushnth 1 + dropnth
  0 1 nbrot
fn veceqr_loop
  1 nbrot
    1 +
  1 nbrot
  /* if not equal then false */
  2 pushnth 2 pushnth 2 pushnth 1 nbrot -1 * + 4 + pushnth = ! veceq_false :if
  2 dropnth
  0 pushnth 2 pushnth -1 * + 2 + dropnth
  1 pushnth 1 pushnth < veceqr_loop :if
  veceq_true :
fn veceq_loop2
  1 nbrot
    1 +
  1 nbrot
  1 pushnth 1 pushnth < ! veceq_end :if
  2 dropnth
  0 pushnth 2 pushnth -1 * + dropnth
  veceq_loop2 :
fn veceq_end
  0 dropnth 0 dropnth 0 dropnth 0 dropnth
  1 nbrot :
fn veceq_false
  1 nbrot -1 * + 1 + 0 1 nbrot
  0 1 pushnth 2 * 2 + nbrot
  veceq_loop2 :
fn veceq_true
  0 dropnth 0 dropnth 1 1 nbrot :
fn veceq_len_false
  call vecrem :
  call vecrem :
  0 1 nbrot :

fn compiler
  argc 2 < err :if
  1 argv "sim" call veceq : sim-mode :if
  1 argv "s" call veceq : sim-mode :if
  1 argv "version" call veceq : version :if
  1 argv "ver" call veceq : version :if
  1 argv "v" call veceq : version :if
  1 argv "usage" call veceq : usage :if
  1 argv "u" call veceq : usage :if
  1 argv "help" call veceq : usage :if
  1 argv "h" call veceq : usage :if
  "Unknown subcommand: `" puts 1 argv puts '` putc 10 putc
  usage :
  1 exit
fn err
  "No subcommand provided" puts 10 putc
  usage :
fn usage
  "usage: subcommand option... source..." puts 10 putc
  "subcommand:" puts 10 putc
  "  sim, s                simulate (interpret) program" puts 10 putc
  "  version, ver, v       print version inforvec2ion and exit" puts 10 putc
  "  usage, u, help, h     print this message and exit" puts 10 putc
  "NI = not implemented" puts 10 putc
  1 exit
fn version
  "F+, a stack-based programming language" puts 10 putc
  "written on itself on Rust" puts 10 putc
  "version: 0.1.0 alpha07" puts 10 putc
  "download: https://github.com/TwoSpikes/fplus" puts 10 putc
  "2022-2023 @ TwoSpikes" puts 10 putc
  0 exit
fn sim-mode
  argc 3 < no-files :if
  "files: " puts 10 putc
  call 1 sim-mode-files-loop :
  "sim-mode is not implemented yet" puts 10 putc
  1 exit
fn no-files
  "No source file provided" puts 10 putc
  usage :
fn sim-mode-files-loop
  1 +
  0 pushnth argc < ! 2 pushnth :if
  /* print filename */
  0 pushnth argv puts 10 putc
  /* print file */
  0 pushnth argv read puts
    0 pushnth argv read
    0 pushnth 1 + pushnth argv
  /* call lex : */
  ???
  sim-mode-files-loop :

/*
*  2dvector is not the same as matrix
*/

/* return elements count in 2dvector */
fn vec2len-sum
  1 4 pushnth
  vec2len-sum-loop :
fn vec2len-sum-loop
  1 pushnth 4 pushnth < ! vec2len-sum-end :if
  1 nbrot
    1 +
  1 nbrot
  0 pushnth 5 + 2 pushnth -1 + + pushnth +
  vec2len-sum-loop :
fn vec2len-sum-end
  3 dropnth 1 dropnth 1 nbrot :

/* remove the 2dvector */
fn vec2rem
  "vec2rem is not implemented yet cuz shvecrem is not implemented yet" puts 10 putc
  1 exit

/* copy the 2dvector */
fn vec2cpy /* bar3baz33*11<3 */
  0
  vec2cpy-loop :
fn vec2cpy-loop
  1 +
  "vec2cpy-loop is not implemented yet" puts 10 putc
  ???
  0 pushnth 3 pushnth < ! vec2cpy-end :if
  vec2cpy-loop :
fn vec2cpy-end
  "vec2cpy-end" puts 10 putc
  ???
  
fn main
    "foo" "bar" "baz" 3 ??#
  call vec2cpy :
  "main" puts 10 putc
  ???

/*
fn vecpushnth ???

fn main
  "ab" "cd" "ee" "zy"
  call 2 vecpushnth :
  puts puts puts puts puts 10 putc
  0 exit
*/

/*
fn lex
  1 pushnth 1 + nbrot
  "[lexing " puts call veccpy : puts '] putc 10 putc
  /* 0 pushnth 1 + pushnth
  1 pushnth 2 + dropnth
  1 pushnth 0 pushnth 3 + pushnth + 2 + nbrot */
  ??# call 0 vecpushnth : ???
  :
*/


/* remove a vector with stack shift (from right). Needed for ve2rem. */
fn shvecrem
  "shvecrem is not implemented yet" puts 10 putc
  1 exit

/* copy a vector with stack shift to the top of the stack with shift from right. Needed for vec2cpy. */
fn shveccpy
  "shveccpy is not implemented yet" puts 10 putc
  1 exit
